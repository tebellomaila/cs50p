## CS50's Introduction to Programming with Python

### Problem Sets 2: Coke Machine, camelCase, Just setting up my Twttr, Nutrition Facts, Vanity Plate Validator

The past few weeks has been all about string manipulation, input validation, use of dictionaries and lists in Python. I worked through five different projects from CS50P's Problem Set 2, each with their own unique challenges. At first, I felt overwhelmed looking at all the requirements, but breaking them down into smaller problems helped tremendously.

I started with the `Coke machine simulator` problem set. The goal was to prompt the user for coins until they've paid at least 50 cents, then calculate change. But my initial implementation had issues with input validation. My Mistake was I created an get_valid_coin function that would return 0 for invalid coins but didn't properly handle reprompting. The while loop was pointless since I returned immediately. What I learned from this input validation requires careful looping and functions should have clear and modular task. Sometines it's better to handle validation in the main loop rather than using helper functions that prompts until getting valid input which felt much cleaner

The `camelCase` problem set. This one seemed straightforward until I considered edge cases, say if the input started with uppercase or numbers. I realized I could process each character individually, adding underscores before uppercase letters (except the first character). The solution was more efficient with list comprehensions. I initially used the same variable name for the function and a list inside it. Renaming the inner variable to snake_chars made it much clearer. And then the `Twttr problem` set, the goal was simple to remove all vowels from text input.I used a string of vowels and built a new string by iterating through each character. The `Nutrition Fact` problem set taught me about dictionaries and case-insentive matching.The FDA provides specific calorie counts for fruits, and I needed to create a dictionary for this. I used built-in lower() function on the input to handle case insensitivity and learned to work with dictionary lookups. I also added try-except blocks to improve the program, even though the problem didn't strictly require it. The `Vanity Plate Validator` problem set was the most challenging project! So many rules to validate: Start with at least two letters Length between 2-6 characters Numbers only at the end First number can't be zero No special characters

I kept getting "TypeError: 'bool' object is not subscriptable" errors. It took me forever to realize I was accidentally passing boolean values between functions instead of strings! I restructured my code to use early returns and a flag system for tracking number placement. Instead of trying to find numbers by index positions, I used boolean flag (is_number) to track whether I'd encountered any digits yet. So I learned that early returns make code cleaner and easier to debug and order of validation matters and testing edge cases is important. This problem set pushed me to think more carefully about code structure and validation. I'm getting better at breaking complex problems into smaller, manageable functions. My debugging skills have improved - I'm learning to read error messages more carefully and trace through execution flow. I still need to work on writing test cases before implementing solutions. Considering all edge cases upfront and using more descriptive variable names. But overall, I'm proud of my progress. Each project felt like a puzzle, and there's something interesting about seeing all the test cases pass after hours of debugging. I want to learn more about regular expressions for pattern matching and explore unit testing frameworks in Python

### Problem Sets 3: Fuel Gauge, Felipe's Taquaria, Grocery List, Outdated

It has been an exploration of logic, problem-solving, and personal growth. Over the past weeks, I dedicated myself to understanding the fundamental concepts of Python through . Each program I built presented unique challenges, requiring patience, creativity, and analytical thinking. Reflecting on this journey, not only in technical skill.

One of the problem sets I tackled was a `fuel gauge calculator`, which reads a fraction representing the fuel level and outputs the corresponding percentage or “E” for empty and “F” for full. Initially, handling invalid inputs, such as missing slashes, letters, or division by zero, was challenging. I learned that anticipating user errors and handling them gracefully is a critical part of programming. Breaking the logic into two functions — `convert()` to process the fraction and `gauge()` to determine the display taught me the importance of modular design, making my code easier to read, test, and maintain. For example, if a user inputted 1/2, the program would output 50%. Handling invalid inputs like 3/0 or abc initially felt overwhelming, but I learned to anticipate errors and implement proper validation using Python’s tools for exception handling.

Creating functions to get valid integer input reinforced modular design and code reusability. For example, a get_int(prompt) function repeatedly asks the user for input until a valid integer is supplied. In some cases, I used pass to silently retry input, while in others, I provided error messages to guide myself while fixing errors in my code. This taught me that programming is not only about logic but also about user experience design and resilience against unexpected input. I explored the `taqueria order checker` program. This problem set involved a menu dictionary and real-time order tracking. The challenge here was handling unexpected inputs, like invalid menu items or varied capitalization. For example, whether a user typed `Beef taco` or `beef TACO`, the program correctly recognized the order. This was achieved by normalizing input strings. The challenge here was implement a program that could handle unexpected inputs, such as invalid menu items or varied capitalization. I learned how Python’s built-in functions, such as `.title()` for case normalization and `.keys()` for dictionary access can help create error-prone programs. Extending the project to display a formatted receipt introduced me to the importance of output formatting and user experience. Small, thoughtful transformations can dramatically improve accuracy. The `grocery list` problem set challenged my understanding of data structures and efficiency. Users could input multiple items, and the program counted occurrences, ignored blank lines, and displayed a final list sorted alphabetically in uppercase. I needed to continuously accept input from users, count the number of occurrences of each item, and output the final list in uppercase, sorted alphabetically, with counts. Handling case-insensitive input, ignoring blank lines, and maintaining correct counts forced me to experiment with different approaches, from using dictionaries with exception handling to leveraging Python’s keys() method for simplicity. It reinforced my understanding of the importance of normalization, error handling, and output formatting, while highlighting the need to anticipate edge cases in user interaction.

Finally, the date conversion program challenged me with real-world data handling. Accepting dates in both numeric (MM/DD/YYYY) and textual (Month DD, YYYY) formats and converting them to the ISO standard required careful parsing and validation. For example, February 28, 2025 would become 2025-02-28, while invalid dates like 02/30/2025 were rejected. This taught me how Python’s datetime module can simplify real-world problems. Ensuring that the program accepted case-insensitive month names, ignored extra spaces, and rejected impossible dates (like February 30) deepened my understanding of input validation, string manipulation, and learning about the Python’s datetime module for accurate real-world applications. This project highlighted the importance of combining logical thinking with attention to detail, as even small oversights can lead to incorrect outputs.

Looking back, these projects collectively taught me several invaluable lessons. Input validation and error handling are critical to creating resilient programs. Modular design enhances readability, maintainability, and testability. Normalization and consistency in data ensure reliable outcomes, while thoughtful output formatting improves usability. Perhaps most importantly, I learned that programming is as much about mindset as it is about syntax: patience, curiosity, and the willingness to iterate on solutions are essential qualities for growth. A critical concept I applied across all these projects was exception handling using try and except. I learned that exceptions are runtime errors—problems that arise while the program is running. For example, attempting to convert a string like "cat" into an integer produces a ValueError. Using try-except blocks allowed me to anticipate and manage runtime errors gracefully. By combining try, except, and else, I could catch errors, provide feedback to the user, and only proceed with valid data.

In conclusion, learning Python has been engaging and rewarding. From handling fractions and dictionary lookups to managing grocery lists and parsing dates, each challenge taught me something new about coding and problem-solving. Beyond technical skills, I cultivated a disciplined approach to designing programs that are robust, user-friendly, and efficient. These lessons have strengthened my abilities as a beginner programmer and equipped me with the mindset to tackle increasingly complex challenges with confidence and precision.

